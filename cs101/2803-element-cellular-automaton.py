# THREE GOLD STARS
# Question 3-star: Elementary Cellular Automaton

# Please see the video for additional explanation.

# A one-dimensional cellular automata takes in a string, which in our 
# case, consists of the characters '.' and 'x', and changes it according 
# to some predetermined rules. The rules consider three characters, which 
# are a character at position k and its two neighbours, and determine 
# what the character at the corresponding position k will be in the new 
# string.

# For example, if the character at position k in the string  is '.' and 
# its neighbours are '.' and 'x', then the pattern is '..x'. We look up 
# '..x' in the table below. In the table, '..x' corresponds to 'x' which 
# means that in the new string, 'x' will be at position k.

# Rules:
#          pattern in         position k in        contribution to
# Value    current string     new string           pattern number
#                                                  is 0 if replaced by '.'
#                                                  and value if replaced
#                                                  by 'x'
#   1       '...'               '.'                        1 * 0
#   2       '..x'               'x'                        2 * 1
#   4       '.x.'               'x'                        4 * 1
#   8       '.xx'               'x'                        8 * 1
#  16       'x..'               '.'                       16 * 0
#  32       'x.x'               '.'                       32 * 0
#  64       'xx.'               '.'                       64 * 0
# 128       'xxx'               'x'                      128 * 1
#                                                      ----------
#                                                                                                    142

# To calculate the patterns which will have the central character x, work 
# out the values required to sum to the pattern number. For example,
# 32 = 32 so only pattern 32 which is x.x changes the central position to
# an x. All the others have a . in the next line.

# 23 = 16 + 4 + 2 + 1 which means that 'x..', '.x.', '..x' and '...' all 
# lead to an 'x' in the next line and the rest have a '.'

# For pattern 142, and starting string
# ...........x...........
# the new strings created will be
# ..........xx...........  (generations = 1)
# .........xx............  (generations = 2)
# ........xx.............  (generations = 3)
# .......xx..............  (generations = 4)
# ......xx...............  (generations = 5)
# .....xx................  (generations = 6)
# ....xx.................  (generations = 7)
# ...xx..................  (generations = 8)
# ..xx...................  (generations = 9)
# .xx....................  (generations = 10)

# Note that the first position of the string is next to the last position 
# in the string.

# Define a procedure, cellular_automaton, that takes three inputs: 
#     a non-empty string, 
#     a pattern number which is an integer between 0 and 255 that
# represents a set of rules, and 
#     a positive integer, n, which is the number of generations. 
# The procedure should return a string which is the result of
# applying the rules generated by the pattern to the string n times.

def parse_pattern(pattern):
    bin_str = lambda s, digit: bin(s)[2:].zfill(digit)
    pattern = list(reversed(bin_str(pattern, 8)))
    state_map = {}
    m = {'1': 'x', '0': '.'}
    for i in range(len(pattern)):
        cur_state = ''.join([m[d] for d in bin_str(i, 3)])
        nxt_state = m[pattern[i]]
        state_map[cur_state] = nxt_state
    return state_map
    
def parse_pattern(pattern):
    patterns = ['xxx', 'xx.', 'x.x', 'x..', '.xx', '.x.', '..x', '...']
    outcomes = ['x' if i == '1' else '.' for i in bin(pattern)[2:].zfill(8)]
    return {i:j for i,j in zip(patterns, outcomes)}
    
def cellular_automaton(state, pattern, n):
    w = len(state)
    state_map = parse_pattern(pattern)
    for i in range(n):
        state = state[-1]+state+state[0]
        state = ''.join([state_map[state[i:i+3]] for i in range(w)])
    return state

print cellular_automaton('...........x...........', 142, 1) == '..........xx...........'
print cellular_automaton('...........x...........', 142, 2) == '.........xx............'
print cellular_automaton('...........x...........', 142, 3) == '........xx.............'
print cellular_automaton('...........x...........', 142, 4) == '.......xx..............'
print cellular_automaton('...........x...........', 142, 5) == '......xx...............'
print cellular_automaton('...........x...........', 142, 6) == '.....xx................'
print cellular_automaton('...........x...........', 142, 7) == '....xx.................'
print cellular_automaton('...........x...........', 142, 8) == '...xx..................'
print cellular_automaton('...........x...........', 142, 9) == '..xx...................'
print cellular_automaton('...........x...........', 142,10) == '.xx....................'

print cellular_automaton('.x.x.x.x.', 17, 2)  == 'xxxxxxx..'
print cellular_automaton('.x.x.x.x.', 249, 3) == '.x..x.x.x'
print cellular_automaton('...x....', 125, 1)  == 'xx.xxxxx'
print cellular_automaton('...x....', 125, 2)  == '.xxx....'
print cellular_automaton('...x....', 125, 3)  == '.x.xxxxx'
print cellular_automaton('...x....', 125, 4)  == 'xxxx...x'
print cellular_automaton('...x....', 125, 5)  == '...xxx.x'
print cellular_automaton('...x....', 125, 6)  == 'xx.x.xxx'
print cellular_automaton('...x....', 125, 7)  == '.xxxxx..'
print cellular_automaton('...x....', 125, 8)  == '.x...xxx'
print cellular_automaton('...x....', 125, 9)  == 'xxxx.x.x'
print cellular_automaton('...x....', 125, 10) == '...xxxxx'

